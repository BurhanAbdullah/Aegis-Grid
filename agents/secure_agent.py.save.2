class SecureAgent:
    """
    Adaptive security agent controlling fragmentation,
    dummy injection, and time-bounded correctness.
    """

    def __init__(self, master_key: bytes):
        # Root secret
        self.master_key = master_key

        # Threat estimation
        self.threat_score = 0.0

        # Fragmentation & obfuscation policy
        self.fragment_count = 8
        self.dummy_ratio = 1.0

        # Timing constraint
        self.time_window_ms = 50

        # Runtime state
        self.expected_real_fragments = 0
        self.last_nonce = None

    def update(self, loss: float, delay: float):
        """
        Update internal threat score based on observed network behavior.
        """
        self.threat_score = min(
            1.0,
            0.7 * self.threat_score + 0.3 * (loss + delay)
        )
        self._adapt_policy()

    def _adapt_policy(self):
        """
        Adaptive control logic.
        """
        self.fragment_count = int(8 + 8 * self.threat_score)
        self.dummy_ratio = min(3.0, 1.0 + 2.0 * self.threat_score)

    def decide_dummy_ratio(self) -> float:
        return self.dummy_ratio
class SecureAgent:
    def __init__(self, master_key):
        self.master_key = master_key
        self.threat_score = 0.0
        self.expected_real_fragments = 0
        self.last_nonce = None

    def update(self, loss, delay):
        self.threat_score = min(1.0, 0.7*self.threat_score + 0.3*(loss + delay))

    def decide_dummy_ratio(self):
        return 1.0 + 2.0 * self.threat_score
/home/codespace/.python/current/bin/python /workspaces/agentic-secure-grid-communication/core/crypto.py
find . -name "__pycache__" -type d -exec rm -rf {} +


