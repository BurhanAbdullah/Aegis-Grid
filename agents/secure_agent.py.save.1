class SecureAgent:
    """
    Adaptive security agent controlling fragmentation,
    dummy injection, and time-bounded correctness.
    """

    def __init__(self, master_key: bytes):
        # Root secret
        self.master_key = master_key

        # Threat estimation
        self.threat_score = 0.0

        # Fragmentation policy (REQUIRED by protocol)
        self.fragment_count = 8          # base fragments
        self.dummy_ratio = 1.0           # base dummy ratio

        # Timing constraints
        self.time_window_ms = 50

        # Runtime state
        self.expected_real_fragments = 0
        self.last_nonce = None

    def update(self, loss: float, delay: float):
        """
        Update internal threat score based on observed network behavior.
        """
        self.threat_score = min(
            1.0,
            0.7 * self.threat_score + 0.3 * (loss + delay)
        )

        # Adapt policy
        self._adapt_policy()

    def _adapt_policy(self):
        """
        Deterministic adaptive control.
        Can be replaced by RL / learning-based logic later.
        """
        self.fragment_count = int(8 + 8 * self.threat_score)
        self.dummy_ratio = min(3.0, 1.0 + 2.0 * self.threat_score)

    def decide_dummy_ratio(self) -> float:
        """
        Backward compatibility if used elsewhere.
        """
        return self.dummy_ratio
class SecureAgent:
    def __init__(self, master_key):
        self.master_key = master_key
        self.threat_score = 0.0
        self.expected_real_fragments = 0
        self.last_nonce = None

    def update(self, loss, delay):
        self.threat_score = min(1.0, 0.7*self.threat_score + 0.3*(loss + delay))

    def decide_dummy_ratio(self):
        return 1.0 + 2.0 * self.threat_score
x
python - << 'EOF'
from agents.secure_agent import SecureAgent
from Crypto.Random import get_random_bytes

a = SecureAgent(get_random_bytes(16))
print(a.fragment_count, a.dummy_ratio)
EOF

